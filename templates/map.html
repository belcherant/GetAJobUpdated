{% extends "layout.html" %}

{% block title %}Jobs Map — GetAJob{% endblock %}

{% block head %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
  /* Map page layout */
  .map-card {
    max-width:1100px;
    margin:18px auto;
    padding:12px;
  }

  .map-wrapper {
    display:flex;
    gap:12px;
    align-items:stretch;
    min-height:56vh;
  }

  /* Map canvas */
  #map {
    position: relative;
    flex:1;
    min-height:48vh;
    height:56vh;
    width:100%;
    border-radius:8px;
    border:1px solid rgba(0,0,0,0.06);
    background:#f3f5f7;
    overflow:hidden;
    z-index:0;
  }

  /* Static-image fallback inside map when tiles fail */
  #map img.static-fallback {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: 0;
  }

  /* Overlay used for library/tile error messages */
  #mapOverlay {
    position: absolute;
    inset: 0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    background: rgba(255,255,255,0.6);
    z-index: 1000;
    font-size:1rem;
    color:#333;
  }
  #mapOverlay.hidden { display:none; pointer-events:none; }

  .sidebar {
    width:320px;
    max-width:34%;
    display:flex;
    flex-direction:column;
  }

  .sidebar .card {
    padding:8px;
    border-radius:8px;
    background:#fff;
    border:1px solid rgba(0,0,0,0.06);
    height:100%;
    overflow:auto;
  }

  .job-list-mini { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:8px; }
  .job-list-mini a { display:block; padding:8px; border-radius:6px; text-decoration:none; color:var(--text); border:1px solid rgba(0,0,0,0.04); background:#fff; }
  .job-empty { color:var(--muted); padding:12px; }

  .map-controls { display:flex; gap:8px; margin-bottom:8px; flex-wrap:wrap; align-items:center; }
  .map-controls input[type="search"], .map-controls select { padding:8px; border-radius:6px; border:1px solid rgba(0,0,0,0.08); }
  .map-controls .btn { padding:8px 10px; border-radius:6px; }

  .suggestions-list { position:relative; max-height:200px; overflow:auto; margin-top:6px; border:1px solid rgba(0,0,0,0.06); border-radius:6px; background:#fff; z-index:1000; }
  .suggestions-list button { width:100%; text-align:left; padding:8px; border:0; background:transparent; cursor:pointer; }

  /*
    Prevent global img rules (e.g., img { max-width:100% }) from breaking Leaflet tiles.
  */
  .leaflet-container img {
    max-width: none !important;
    display: block !important;
    image-rendering: auto !important;
  }
  .leaflet-container .leaflet-tile {
    width: 256px !important;
    height: 256px !important;
  }

  @media (max-width:900px) {
    .map-wrapper { flex-direction:column; }
    .sidebar { width:100%; max-width:100%; }
    #map { height:420px; min-height:360px; }
  }
</style>
{% endblock %}

{% block content %}
<div class="card map-card">
  <div class="map-wrapper">
    <div id="map" aria-label="Jobs map">
      <!-- overlay is hidden by default; shown only for library-missing or persistent tile failure -->
      <div id="mapOverlay" class="hidden">Loading map…</div>
    </div>

    <aside class="sidebar">
      <div class="card">
        <div class="map-controls" role="toolbar" aria-label="Map controls">
          <button id="btnLocate" class="btn btn-outline" title="Use browser location">Locate me</button>

          <div style="flex:1;">
            <div class="search-suggestions">
              <input id="addrSearch" type="search" placeholder="Search address or place..." style="width:100%;" />
              <div id="suggestions" class="suggestions-list" style="display:none;"></div>
            </div>
          </div>

          <select id="radiusSelect" title="Radius (miles)">
            <option value="5">5 mi</option>
            <option value="10" selected>10 mi</option>
            <option value="25">25 mi</option>
            <option value="50">50 mi</option>
          </select>
          <button id="btnApply" class="btn btn-primary">Search</button>
        </div>

        <h3 style="margin-top:6px;">Jobs nearby</h3>
        <div id="jobsList" style="margin-top:6px;">
          <div class="job-empty">Locating and loading jobs...</div>
        </div>
      </div>
    </aside>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
(function () {
  // Helper: escape HTML for popup content
  function escapeHtml(s) {
    if (s === null || s === undefined) return '';
    return String(s).replace(/[&<>"']/g, function (m) {
      return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m];
    });
  }

  const btnLocate = document.getElementById('btnLocate');
  const addrSearch = document.getElementById('addrSearch');
  const suggestionsEl = document.getElementById('suggestions');
  const btnApply = document.getElementById('btnApply');
  const radiusSelect = document.getElementById('radiusSelect');
  const jobsListEl = document.getElementById('jobsList');
  const mapEl = document.getElementById('map');
  const mapOverlay = document.getElementById('mapOverlay');

  let map, markersLayer, userMarker, radiusCircle;
  let currentCenter = { lat: 39.8283, lng: -98.5795 }; // default US center
  let currentRadius = Number(radiusSelect.value) || 10; // miles

  function showOverlay(msg) {
    if (!mapOverlay) return;
    mapOverlay.textContent = msg || '';
    mapOverlay.classList.remove('hidden');
  }
  function hideOverlay() {
    if (!mapOverlay) return;
    mapOverlay.classList.add('hidden');
  }

  // Build a staticmap URL for fallback (single image, not interactive)
  function staticMapUrl(lat, lon, zoom) {
    // staticmap.openstreetmap.de has some usage limits but is convenient for quick dev fallback
    const z = zoom || 4;
    const size = '1024x512';
    return `https://staticmap.openstreetmap.de/staticmap.php?center=${lat},${lon}&zoom=${z}&size=${size}&markers=${lat},${lon},red-pushpin`;
  }

  // Append a static fallback image into the map container (removes leaflets layers)
  function showStaticFallback(lat, lon, zoom) {
    // remove any existing leaflet map (if present)
    try {
      if (map) {
        map.remove();
        map = null;
      }
    } catch (e) { /* ignore */ }

    // remove any existing fallback img
    const existing = mapEl.querySelector('img.static-fallback');
    if (existing) existing.remove();

    const img = document.createElement('img');
    img.className = 'static-fallback';
    img.alt = 'Map preview';
    img.src = staticMapUrl(lat, lon, zoom || 4);
    // hide overlay (we show the image)
    hideOverlay();
    mapEl.appendChild(img);
  }

  function initMapOnce() {
    // If Leaflet missing, show overlay and bail
    if (!window.L || !window.L.map) {
      console.warn('Leaflet not available');
      showOverlay('Map library not loaded');
      // Also try to display a static fallback so the UI isn't blank
      showStaticFallback(currentCenter.lat, currentCenter.lng, 4);
      return;
    }
    if (window.__jobs_map_inited) return;
    window.__jobs_map_inited = true;

    // create the map (use preferCanvas to reduce DOM pressure)
    map = L.map('map', { preferCanvas: true }).setView([currentCenter.lat, currentCenter.lng], 5);

    // Use configured tile provider if provided by Flask context, otherwise default OSM
    const tileUrl = '{{ TILE_URL|default("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png") }}';
    const tileAttr = '{{ TILE_ATTRIBUTION|default("&copy; OpenStreetMap contributors")|e }}';

    const tileOpts = {
      attribution: tileAttr,
      maxZoom: 19,
      detectRetina: false,
      updateWhenIdle: true,      // reduce requests while dragging/zooming
      updateWhenZooming: false,
      keepBuffer: 2
    };

    // Primary (configured) tiles
    const primaryTiles = L.tileLayer(tileUrl, tileOpts).addTo(map);

    // Fallback tiles (CartoCDN)
    const fallbackUrl = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png';
    const fallbackOpts = { attribution: '&copy; OpenStreetMap contributors & CartoDB', maxZoom: 19 };
    const fallbackTiles = L.tileLayer(fallbackUrl, fallbackOpts);

    markersLayer = L.layerGroup().addTo(map);

    userMarker = L.circleMarker([currentCenter.lat, currentCenter.lng], {
      radius: 8,
      fillColor: getComputedStyle(document.documentElement).getPropertyValue('--primary') || '#0ea5a4',
      color: '#fff',
      weight: 2,
      opacity: 1,
      fillOpacity: 1,
    }).addTo(map);
    userMarker.setStyle({ opacity: 0, fillOpacity: 0 });

    // controls wiring
    btnLocate.addEventListener('click', locateAndApply);
    btnApply.addEventListener('click', () => {
      currentRadius = Number(radiusSelect.value) || currentRadius;
      const center = map ? map.getCenter() : {lat: currentCenter.lat, lng: currentCenter.lng};
      currentCenter.lat = center.lat;
      currentCenter.lng = center.lng;
      loadJobsAndRender(currentCenter.lat, currentCenter.lng, currentRadius);
    });
    radiusSelect.addEventListener('change', () => {
      currentRadius = Number(radiusSelect.value) || currentRadius;
      if (currentCenter && currentCenter.lat && currentCenter.lng) {
        loadJobsAndRender(currentCenter.lat, currentCenter.lng, currentRadius);
      }
    });

    let debounceTimer = null;
    addrSearch.addEventListener('input', function () {
      clearTimeout(debounceTimer);
      const q = (this.value || '').trim();
      if (!q) {
        suggestionsEl.style.display = 'none';
        suggestionsEl.innerHTML = '';
        return;
      }
      debounceTimer = setTimeout(() => doAddressLookup(q), 300);
    });

    // invalidate once after mount to ensure sizing
    setTimeout(() => { try { map.invalidateSize(); } catch (e) {} }, 300);
    let winResizeTimer = null;
    window.addEventListener('resize', () => {
      if (winResizeTimer) clearTimeout(winResizeTimer);
      winResizeTimer = setTimeout(() => { try { map.invalidateSize(); } catch (e) {} }, 200);
    });

    // Tile error handling and switch to fallback or static image if required.
    let primaryErrors = 0;
    const primaryErrorThreshold = 6; // number of tile errors to consider provider failing

    function trySwitchToFallbackOrStatic() {
      try {
        if (map && map.hasLayer(primaryTiles)) map.removeLayer(primaryTiles);
      } catch (e) { /* ignore */ }

      // Try fallback tiles first
      try {
        if (!map.hasLayer(fallbackTiles)) {
          fallbackTiles.addTo(map);
        }
      } catch (e) {
        console.error('fallback tile add failed', e);
      }

      // If fallback also doesn't load within a short period, replace with static image
      let fallbackLoaded = false;
      fallbackTiles.once('load', function () { fallbackLoaded = true; hideOverlay(); try { map.invalidateSize(); } catch (e) {} });
      fallbackTiles.once('tileerror', function (e) { console.warn('fallback tile error', e); });

      setTimeout(() => {
        if (!fallbackLoaded) {
          console.warn('Fallback tiles not loading — showing static fallback image');
          // show a single static image preview to avoid blank UI and stop tile storms
          showStaticFallback(currentCenter.lat, currentCenter.lng, 4);
        }
      }, 2500);
    }

    primaryTiles.on('load', function () {
      hideOverlay();
      try { map.invalidateSize(); } catch (e) {}
    });

    primaryTiles.on('tileerror', function (e) {
      primaryErrors++;
      console.warn('Primary tile error', primaryErrors, e);
      // If many primary tileerrors, switch to fallback or static preview
      if (primaryErrors >= primaryErrorThreshold) {
        showOverlay('Primary map provider failed — switching to fallback');
        trySwitchToFallbackOrStatic();
      }
    });

    fallbackTiles.on('tileerror', function (e) {
      console.error('Fallback tile error', e);
      // Let the static fallback logic handle showing image after timeout
    });

    // If tiles are very slow, reveal map (don't block UI indefinitely)
    let tilesLoaded = false;
    const markLoaded = () => { tilesLoaded = true; hideOverlay(); try { map.invalidateSize(); } catch (e) {} };
    primaryTiles.once('load', markLoaded);
    fallbackTiles.once('load', markLoaded);

    setTimeout(() => {
      if (!tilesLoaded) {
        console.warn('Tiles not loaded after timeout — revealing map for user interaction.');
        hideOverlay();
      }
    }, 8000);

    // initial locate flow
    (async function initialLocate() {
      const ok = await tryBrowserGeolocation();
      if (!ok) {
        try {
          const resp = await fetch('/_client_location');
          const j = await resp.json();
          if (j && j.ok && j.lat && j.lon) {
            currentCenter.lat = j.lat;
            currentCenter.lng = j.lon;
            setUserLocationMarker(j.lat, j.lon, true);
            currentRadius = Number(radiusSelect.value) || currentRadius;
            loadJobsAndRender(currentCenter.lat, currentCenter.lng, currentRadius);
            return;
          }
        } catch (e) { console.warn('IP geolookup failed', e); }
        // no location available; load all jobs (unfiltered)
        loadJobsAndRender();
      }
    })();
  }

  async function locateAndApply() {
    const ok = await tryBrowserGeolocation();
    if (!ok) {
      alert('Unable to get browser location. Check permissions.');
    }
  }

  async function tryBrowserGeolocation() {
    if (!navigator.geolocation) return false;
    return new Promise(resolve => {
      let settled = false;
      navigator.geolocation.getCurrentPosition(async (pos) => {
        settled = true;
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        currentCenter.lat = lat;
        currentCenter.lng = lng;
        currentRadius = Number(radiusSelect.value) || currentRadius;
        setUserLocationMarker(lat, lng, true);
        map && map.setView([lat, lng], 13);
        await loadJobsAndRender(lat, lng, currentRadius);
        resolve(true);
      }, (err) => {
        console.warn('geolocation error', err);
        if (!settled) resolve(false);
      }, { maximumAge: 60 * 1000, timeout: 8000, enableHighAccuracy: false });
      setTimeout(() => { if (!settled) resolve(false); }, 9000);
    });
  }

  function setUserLocationMarker(lat, lng, show=true) {
    if (!userMarker) return;
    try {
      userMarker.setLatLng([lat, lng]);
    } catch (e) { /* ignore */ }
    if (show) {
      userMarker.setStyle({ opacity: 1, fillOpacity: 1 });
      if (radiusCircle) map.removeLayer(radiusCircle);
      radiusCircle = L.circle([lat, lng], { radius: (currentRadius || 10) * 1609.344, color: '#0077ff', opacity: 0.12, weight: 1, fillOpacity: 0.04 }).addTo(map);
    } else {
      userMarker.setStyle({ opacity: 0, fillOpacity: 0 });
      if (radiusCircle) { map.removeLayer(radiusCircle); radiusCircle = null; }
    }
  }

  async function doAddressLookup(q) {
    const url = 'https://nominatim.openstreetmap.org/search?format=json&limit=6&q=' + encodeURIComponent(q);
    try {
      const resp = await fetch(url, { headers: { 'Accept-Language': 'en' } });
      const arr = await resp.json();
      suggestionsEl.innerHTML = '';
      if (!Array.isArray(arr) || arr.length === 0) { suggestionsEl.style.display = 'none'; return; }
      arr.forEach(item => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.innerHTML = escapeHtml(item.display_name);
        btn.addEventListener('click', function () {
          const lat = parseFloat(item.lat), lon = parseFloat(item.lon);
          currentCenter.lat = lat;
          currentCenter.lng = lon;
          setUserLocationMarker(lat, lon, true);
          suggestionsEl.style.display = 'none';
          suggestionsEl.innerHTML = '';
          addrSearch.value = item.display_name;
          currentRadius = Number(radiusSelect.value) || currentRadius;
          map && map.setView([lat, lon], 13);
          loadJobsAndRender(lat, lon, currentRadius);
        });
        suggestionsEl.appendChild(btn);
      });
      suggestionsEl.style.display = 'block';
    } catch (e) {
      console.error('address lookup failed', e);
      suggestionsEl.style.display = 'none';
    }
  }

  async function loadJobsAndRender(lat=null, lng=null, radius=null) {
    try {
      let url = '/api/jobs';
      if (lat !== null && lng !== null) {
        url = '/api/jobs_nearby?lat=' + encodeURIComponent(lat) + '&lng=' + encodeURIComponent(lng);
        if (radius) url += '&radius_miles=' + encodeURIComponent(radius);
      }
      const resp = await fetch(url);
      if (!resp.ok) { jobsListEl.innerHTML = '<div class="job-empty">Unable to load jobs</div>'; return; }
      const j = await resp.json();
      const jobs = (j.jobs || []);
      renderJobsOnMap(jobs, lat, lng);
    } catch (e) {
      console.error('loadJobsAndRender error', e);
      jobsListEl.innerHTML = '<div class="job-empty">Error loading jobs</div>';
    }
  }

  function renderJobsOnMap(jobs, centerLat=null, centerLng=null) {
    if (!markersLayer) return;
    markersLayer.clearLayers();
    if (radiusCircle) { try { map.removeLayer(radiusCircle); } catch (e) {} radiusCircle = null; }

    jobsListEl.innerHTML = '';
    if (!jobs || jobs.length === 0) {
      jobsListEl.innerHTML = '<div class="job-empty">No jobs available.</div>';
      if (centerLat && centerLng && map) map.setView([centerLat, centerLng], 11);
      return;
    }

    let listHtml = '';
    const layers = [];
    const jobDetailTemplate = '{{ url_for("job_detail", job_id=0) }}';

    jobs.forEach(job => {
      const lat = job.lat !== null ? Number(job.lat) : null;
      const lng = job.lng !== null ? Number(job.lng) : null;
      const displayLoc = job.short_location || (job.location_text||'').split(',').slice(0,2).join(', ');
      const popupHtml = '<div><strong>' + escapeHtml(job.title||'') + '</strong>' +
                        '<div style="font-size:12px;color:#666;margin-top:4px;">' + escapeHtml(displayLoc) + (job.distance_miles ? (' • ' + job.distance_miles + ' mi') : '') + '</div>' +
                        '<div style="margin-top:8px;">' + escapeHtml((job.description||'').substring(0,200)) + (job.description && job.description.length > 200 ? '...' : '') + '</div>' +
                        '<div style="margin-top:6px;"><a href="' + (jobDetailTemplate.replace('/0','/' + encodeURIComponent(job.id))) + '">View job</a> • ' +
                        '<a href="/messages?other_id=' + encodeURIComponent(job.employer_id) + '">Message Poster</a></div></div>';
      if (lat !== null && lng !== null && Number.isFinite(lat) && Number.isFinite(lng) && markersLayer) {
        try {
          const marker = L.marker([lat, lng]).addTo(markersLayer);
          marker.bindPopup(popupHtml);
          layers.push(marker);
        } catch (e) {
          console.warn('Failed to add marker', e);
        }
      }
      listHtml += '<a href="' + (jobDetailTemplate.replace('/0','/' + encodeURIComponent(job.id))) + '"><strong>' + escapeHtml(job.title||'') + '</strong>' +
                  '<div style="font-size:12px;color:#666;margin-top:4px;">' + escapeHtml(displayLoc) + (job.distance_miles ? (' • ' + job.distance_miles + ' mi') : '') + '</div></a>';
    });

    jobsListEl.innerHTML = '<div class="job-list-mini">' + listHtml + '</div>';

    if (centerLat !== null && centerLng !== null && map) {
      try {
        radiusCircle = L.circle([centerLat, centerLng], { radius: (currentRadius || 10) * 1609.344, color: '#0077ff', opacity: 0.12, weight: 1, fillOpacity: 0.04 }).addTo(map);
        map.setView([centerLat, centerLng], 13);
      } catch (e) {}
    } else {
      if (layers.length > 0 && map) {
        try {
          const group = L.featureGroup(layers);
          map.fitBounds(group.getBounds().pad(0.12));
        } catch (e) {
          console.warn('fitBounds failed', e);
        }
      }
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMapOnce);
  } else {
    setTimeout(initMapOnce, 50);
  }
})();
</script>
{% endblock %}
